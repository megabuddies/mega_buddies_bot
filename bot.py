import os
import logging
import asyncio
import time
import json
from typing import List, Dict, Any, Optional, Union, Tuple

from dotenv import load_dotenv
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, 
    CommandHandler, 
    MessageHandler, 
    ContextTypes,
    filters,
    ConversationHandler,
    CallbackQueryHandler
)

from database import Database

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Initialize database
db = Database()

# Admin IDs - replace with actual admin user IDs
ADMIN_IDS = [6327617477]  # Add your admin Telegram user IDs here

# States for conversation handlers
BROADCAST_MESSAGE = 0
AWAITING_CHECK_VALUE = 1
AWAITING_ADD_VALUE = 2
AWAITING_REMOVE_VALUE = 3

# Define command handlers
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handler for the /start command"""
    user = update.effective_user
    chat_id = update.effective_chat.id
    
    # Add user to the database
    db.add_user(
        user_id=user.id,
        username=user.username,
        first_name=user.first_name,
        last_name=user.last_name,
        chat_id=chat_id
    )
    
    # Log the event
    db.log_event("start", user.id)
    
    # Create main menu
    await show_main_menu(update, context)

async def show_main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show the main menu with inline buttons"""
    user = update.effective_user
    
    # Create keyboard with main options
    keyboard = [
        [InlineKeyboardButton("–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤ —Å–ø–∏—Å–∫–µ üîç", callback_data="menu_check")],
        [InlineKeyboardButton("–ü–æ–º–æ—â—å ‚ÑπÔ∏è", callback_data="menu_help")]
    ]
    
    # Add admin section if user is admin
    if user.id in ADMIN_IDS:
        keyboard.append([InlineKeyboardButton("–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å üîß", callback_data="menu_admin")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # Send or edit message based on context
    if update.callback_query:
        # Edit existing message
        await update.callback_query.edit_message_text(
            f"–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é MegaBuddies\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=reply_markup
        )
    else:
        # Send new message
        message = await update.message.reply_text(
            f"–ü—Ä–∏–≤–µ—Ç, {user.first_name}! –Ø –±–æ—Ç MegaBuddies.\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=reply_markup
        )
        # Store message ID for future reference
        if not context.user_data.get('menu_messages'):
            context.user_data['menu_messages'] = []
        context.user_data['menu_messages'].append((chat_id_from_update(update), message.message_id))

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handler for the /help command"""
    await show_help_menu(update, context)

async def show_help_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show the help menu with information"""
    user = update.effective_user
    
    # Base help text for all users
    help_text = (
        "üìã *–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º:*\n\n"
        "‚Ä¢ *–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–∞–Ω–Ω—ã—Ö* ‚Äî –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –±–æ—Ç—É —Ç–µ–∫—Å—Ç –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É \"–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≤ —Å–ø–∏—Å–∫–µ\"\n"
        "‚Ä¢ /start ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\n"
        "‚Ä¢ /help ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É\n"
    )
    
    # Add admin commands if user is admin
    if user.id in ADMIN_IDS:
        help_text += (
            "\n*–ö–æ–º–∞–Ω–¥—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞:*\n"
            "‚Ä¢ /add <–∑–Ω–∞—á–µ–Ω–∏–µ> ‚Äî –¥–æ–±–∞–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –±–∞–∑—É\n"
            "‚Ä¢ /remove <–∑–Ω–∞—á–µ–Ω–∏–µ> ‚Äî —É–¥–∞–ª–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ –±–∞–∑—ã\n"
            "‚Ä¢ /list ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è\n"
            "‚Ä¢ /broadcast ‚Äî –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º\n"
            "‚Ä¢ /stats ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É\n"
        )
    
    # Back button
    keyboard = [[InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_main")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # Send or edit message
    if update.callback_query:
        await update.callback_query.edit_message_text(
            help_text,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    else:
        # Clean up previous menu messages
        await clean_previous_menus(update, context)
        message = await update.message.reply_text(
            help_text,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        # Store message ID
        if not context.user_data.get('menu_messages'):
            context.user_data['menu_messages'] = []
        context.user_data['menu_messages'].append((chat_id_from_update(update), message.message_id))

async def show_check_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Show the check value prompt"""
    keyboard = [[InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_main")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.callback_query:
        await update.callback_query.edit_message_text(
            "–í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤ –≤–∞–π—Ç–ª–∏—Å—Ç–µ:",
            reply_markup=reply_markup
        )
    else:
        # Clean up previous menu messages
        await clean_previous_menus(update, context)
        message = await update.message.reply_text(
            "–í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤ –≤–∞–π—Ç–ª–∏—Å—Ç–µ:",
            reply_markup=reply_markup
        )
        # Store message ID
        if not context.user_data.get('menu_messages'):
            context.user_data['menu_messages'] = []
        context.user_data['menu_messages'].append((chat_id_from_update(update), message.message_id))
    
    return AWAITING_CHECK_VALUE

async def handle_check_value(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Process the value entered for checking"""
    value = update.message.text.strip()
    
    # Check the value against whitelist
    result = db.check_whitelist(value)
    
    # Update user activity
    db.update_user_activity(update.effective_user.id)
    
    # Create response message
    if result:
        message_text = f"‚úÖ –ó–Ω–∞—á–µ–Ω–∏–µ \"{value}\" *–Ω–∞–π–¥–µ–Ω–æ* –≤ –≤–∞–π—Ç–ª–∏—Å—Ç–µ!"
    else:
        message_text = f"‚ùå –ó–Ω–∞—á–µ–Ω–∏–µ \"{value}\" *–Ω–µ –Ω–∞–π–¥–µ–Ω–æ* –≤ –≤–∞–π—Ç–ª–∏—Å—Ç–µ."
    
    # Buttons for next action
    keyboard = [
        [InlineKeyboardButton("üîç –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –¥—Ä—É–≥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ", callback_data="menu_check")],
        [InlineKeyboardButton("‚óÄÔ∏è –í–µ—Ä–Ω—É—Ç—å—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # Clean up previous menu messages
    await clean_previous_menus(update, context)
    
    # Send new response
    message = await update.message.reply_text(
        message_text,
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    
    # Store message ID
    if not context.user_data.get('menu_messages'):
        context.user_data['menu_messages'] = []
    context.user_data['menu_messages'].append((chat_id_from_update(update), message.message_id))
    
    return ConversationHandler.END

async def show_admin_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show the admin panel menu"""
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        # If not admin, show error and return to main menu
        if update.callback_query:
            await update.callback_query.answer("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É —Ä–∞–∑–¥–µ–ª—É.")
            await show_main_menu(update, context)
        else:
            await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É —Ä–∞–∑–¥–µ–ª—É.")
        return
    
    # Admin menu keyboard
    keyboard = [
        [
            InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å", callback_data="admin_add"),
            InlineKeyboardButton("‚ûñ –£–¥–∞–ª–∏—Ç—å", callback_data="admin_remove")
        ],
        [
            InlineKeyboardButton("üìã –°–ø–∏—Å–æ–∫", callback_data="admin_list"),
            InlineKeyboardButton("üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞", callback_data="admin_stats")
        ],
        [
            InlineKeyboardButton("üì® –†–∞—Å—Å—ã–ª–∫–∞", callback_data="admin_broadcast")
        ],
        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="back_to_main")]
    ]
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.callback_query:
        await update.callback_query.edit_message_text(
            "*–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    else:
        # Clean up previous menu messages
        await clean_previous_menus(update, context)
        message = await update.message.reply_text(
            "*–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞*\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        # Store message ID
        if not context.user_data.get('menu_messages'):
            context.user_data['menu_messages'] = []
        context.user_data['menu_messages'].append((chat_id_from_update(update), message.message_id))

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handler for the /stats command"""
    await show_stats_menu(update, context)

async def show_stats_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show bot statistics for admin"""
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        # If not admin, show error
        if update.callback_query:
            await update.callback_query.answer("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É —Ä–∞–∑–¥–µ–ª—É.")
        else:
            await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É —Ä–∞–∑–¥–µ–ª—É.")
        return
    
    try:
        # Get stats from database
        stats = db.get_stats()
        
        # Format statistics message
        stats_text = (
            "*üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞*\n\n"
            
            "*üë• –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:*\n"
            f"‚Ä¢ –í—Å–µ–≥–æ: {stats['users']['total']}\n"
        )
        
        # Add additional user stats if available
        if 'new_7d' in stats['users']:
            stats_text += f"‚Ä¢ –ù–æ–≤—ã—Ö –∑–∞ 7 –¥–Ω–µ–π: {stats['users']['new_7d']}\n"
        if 'new_1d' in stats['users']:
            stats_text += f"‚Ä¢ –ù–æ–≤—ã—Ö –∑–∞ 24 —á–∞—Å–∞: {stats['users']['new_1d']}\n"
        if 'active_7d' in stats['users']:
            stats_text += f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞ 7 –¥–Ω–µ–π: {stats['users']['active_7d']}\n"
        
        stats_text += f"\n*üìã –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö:*\n"
        stats_text += f"‚Ä¢ –ó–∞–ø–∏—Å–µ–π –≤ –≤–∞–π—Ç–ª–∏—Å—Ç–µ: {stats['whitelist']['total']}\n\n"
        
        # Add check stats if available
        if 'checks' in stats:
            stats_text += (
                "*üîç –ü—Ä–æ–≤–µ—Ä–∫–∏:*\n"
                f"‚Ä¢ –ó–∞ 7 –¥–Ω–µ–π: {stats['checks'].get('total_7d', 0)}\n"
                f"  ‚úÖ –£—Å–ø–µ—à–Ω—ã—Ö: {stats['checks'].get('successful_7d', 0)}\n"
                f"  ‚ùå –ù–µ—É–¥–∞—á–Ω—ã—Ö: {stats['checks'].get('failed_7d', 0)}\n"
                f"‚Ä¢ –ó–∞ 24 —á–∞—Å–∞: {stats['checks'].get('total_1d', 0)}\n"
                f"  ‚úÖ –£—Å–ø–µ—à–Ω—ã—Ö: {stats['checks'].get('successful_1d', 0)}\n"
                f"  ‚ùå –ù–µ—É–¥–∞—á–Ω—ã—Ö: {stats['checks'].get('failed_1d', 0)}\n\n"
            )
        
        # Add daily activity if available
        stats_text += "*üìÖ –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ –¥–Ω—è–º:*\n"
        daily_activity = stats.get('daily_activity', {})
        if daily_activity:
            for day, count in daily_activity.items():
                stats_text += f"‚Ä¢ {day}: {count}\n"
        else:
            stats_text += "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö\n"
        
        # Add error info if present
        if 'error' in stats:
            stats_text += f"\n‚ö†Ô∏è *–ü—Ä–∏–º–µ—á–∞–Ω–∏–µ:* –î–∞–Ω–Ω—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ–ø–æ–ª–Ω—ã–º–∏ ({stats['error']})\n"
        
    except Exception as e:
        # Fallback message if stats generation fails
        logger.error(f"Error generating stats: {e}")
        stats_text = (
            "*üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞*\n\n"
            "‚ö†Ô∏è –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.\n"
            f"–î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏: {str(e)}\n\n"
            "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫—É."
        )
    
    # Back buttons
    keyboard = [
        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏", callback_data="menu_admin")],
        [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.callback_query:
        await update.callback_query.edit_message_text(
            stats_text,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    else:
        # Clean up previous menu messages
        await clean_previous_menus(update, context)
        message = await update.message.reply_text(
            stats_text,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        # Store message ID
        if not context.user_data.get('menu_messages'):
            context.user_data['menu_messages'] = []
        context.user_data['menu_messages'].append((chat_id_from_update(update), message.message_id))

async def show_add_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Show menu for adding a value to whitelist"""
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        if update.callback_query:
            await update.callback_query.answer("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É —Ä–∞–∑–¥–µ–ª—É.")
        return ConversationHandler.END
    
    keyboard = [[InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="menu_admin")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.callback_query:
        await update.callback_query.edit_message_text(
            "–í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –≤–∞–π—Ç–ª–∏—Å—Ç:",
            reply_markup=reply_markup
        )
    
    return AWAITING_ADD_VALUE

async def handle_add_value(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Process adding a value to whitelist"""
    value = update.message.text.strip()
    
    # Add to whitelist
    success = db.add_to_whitelist(value)
    
    # Log event
    db.log_event("add_whitelist", update.effective_user.id, {"value": value}, success)
    
    # Create response message
    if success:
        message_text = f"‚úÖ –ó–Ω–∞—á–µ–Ω–∏–µ \"{value}\" —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –≤–∞–π—Ç–ª–∏—Å—Ç!"
    else:
        message_text = f"‚ö†Ô∏è –ó–Ω–∞—á–µ–Ω–∏–µ \"{value}\" —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ –≤–∞–π—Ç–ª–∏—Å—Ç–µ."
    
    # Buttons for next action
    keyboard = [
        [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –µ—â–µ", callback_data="admin_add")],
        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏", callback_data="menu_admin")],
        [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # Clean up previous menu messages
    await clean_previous_menus(update, context)
    
    # Send new response
    message = await update.message.reply_text(
        message_text,
        reply_markup=reply_markup
    )
    
    # Store message ID
    if not context.user_data.get('menu_messages'):
        context.user_data['menu_messages'] = []
    context.user_data['menu_messages'].append((chat_id_from_update(update), message.message_id))
    
    return ConversationHandler.END

async def show_remove_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Show menu for removing a value from whitelist"""
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        if update.callback_query:
            await update.callback_query.answer("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É —Ä–∞–∑–¥–µ–ª—É.")
        return ConversationHandler.END
    
    keyboard = [[InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="menu_admin")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.callback_query:
        await update.callback_query.edit_message_text(
            "–í–≤–µ–¥–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∏–∑ –≤–∞–π—Ç–ª–∏—Å—Ç–∞:",
            reply_markup=reply_markup
        )
    
    return AWAITING_REMOVE_VALUE

async def handle_remove_value(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Process removing a value from whitelist"""
    value = update.message.text.strip()
    
    # Remove from whitelist
    success = db.remove_from_whitelist(value)
    
    # Log event
    db.log_event("remove_whitelist", update.effective_user.id, {"value": value}, success)
    
    # Create response message
    if success:
        message_text = f"‚úÖ –ó–Ω–∞—á–µ–Ω–∏–µ \"{value}\" —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω–æ –∏–∑ –≤–∞–π—Ç–ª–∏—Å—Ç–∞!"
    else:
        message_text = f"‚ùå –ó–Ω–∞—á–µ–Ω–∏–µ \"{value}\" –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –≤–∞–π—Ç–ª–∏—Å—Ç–µ."
    
    # Buttons for next action
    keyboard = [
        [InlineKeyboardButton("‚ûñ –£–¥–∞–ª–∏—Ç—å –µ—â–µ", callback_data="admin_remove")],
        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏", callback_data="menu_admin")],
        [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # Clean up previous menu messages
    await clean_previous_menus(update, context)
    
    # Send new response
    message = await update.message.reply_text(
        message_text,
        reply_markup=reply_markup
    )
    
    # Store message ID
    if not context.user_data.get('menu_messages'):
        context.user_data['menu_messages'] = []
    context.user_data['menu_messages'].append((chat_id_from_update(update), message.message_id))
    
    return ConversationHandler.END

async def show_list_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Show all values in whitelist"""
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        if update.callback_query:
            await update.callback_query.answer("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É —Ä–∞–∑–¥–µ–ª—É.")
        else:
            await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É —Ä–∞–∑–¥–µ–ª—É.")
        return
    
    # Get values from whitelist
    values = db.get_all_whitelist()
    
    # Create response message
    if values:
        values_per_page = 10
        page = context.user_data.get('whitelist_page', 0)
        total_pages = (len(values) + values_per_page - 1) // values_per_page
        
        # Ensure page is valid
        if page >= total_pages:
            page = 0
        
        # Save current page
        context.user_data['whitelist_page'] = page
        
        # Get values for current page
        start = page * values_per_page
        end = min(start + values_per_page, len(values))
        
        message_text = f"*üìã –°–ø–∏—Å–æ–∫ –∑–Ω–∞—á–µ–Ω–∏–π –≤ –≤–∞–π—Ç–ª–∏—Å—Ç–µ ({len(values)} –∑–∞–ø–∏—Å–µ–π)*\n"
        message_text += f"–°—Ç—Ä–∞–Ω–∏—Ü–∞ {page+1} –∏–∑ {total_pages}\n\n"
        
        # Add values with numbering
        for i, value in enumerate(values[start:end], start=start+1):
            message_text += f"{i}. `{value}`\n"
        
        # Navigation buttons
        keyboard = []
        nav_row = []
        
        if total_pages > 1:
            if page > 0:
                nav_row.append(InlineKeyboardButton("‚óÄÔ∏è", callback_data="whitelist_prev"))
            
            nav_row.append(InlineKeyboardButton(f"{page+1}/{total_pages}", callback_data="whitelist_info"))
            
            if page < total_pages - 1:
                nav_row.append(InlineKeyboardButton("‚ñ∂Ô∏è", callback_data="whitelist_next"))
            
            keyboard.append(nav_row)
    else:
        message_text = "üìã –í–∞–π—Ç–ª–∏—Å—Ç –ø—É—Å—Ç."
    
    # Back buttons
    keyboard.append([InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏", callback_data="menu_admin")])
    keyboard.append([InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main")])
    
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.callback_query:
        await update.callback_query.edit_message_text(
            message_text,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
    else:
        # Clean up previous menu messages
        await clean_previous_menus(update, context)
        message = await update.message.reply_text(
            message_text,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        # Store message ID
        if not context.user_data.get('menu_messages'):
            context.user_data['menu_messages'] = []
        context.user_data['menu_messages'].append((chat_id_from_update(update), message.message_id))

async def handle_whitelist_pagination(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle whitelist pagination buttons"""
    query = update.callback_query
    
    # Get current page
    page = context.user_data.get('whitelist_page', 0)
    
    # Update page based on button
    if query.data == "whitelist_next":
        page += 1
    elif query.data == "whitelist_prev":
        page -= 1
    
    # Save updated page
    context.user_data['whitelist_page'] = page
    
    # Show updated list
    await show_list_menu(update, context)

async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Start the broadcast conversation"""
    user = update.effective_user
    if user.id not in ADMIN_IDS:
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return ConversationHandler.END
    
    keyboard = [[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="broadcast_cancel")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    # Clean up previous menu messages
    await clean_previous_menus(update, context)
    
    message = await update.message.reply_text(
        "–í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º:",
        reply_markup=reply_markup
    )
    
    # Store message ID
    if not context.user_data.get('menu_messages'):
        context.user_data['menu_messages'] = []
    context.user_data['menu_messages'].append((chat_id_from_update(update), message.message_id))
    
    return BROADCAST_MESSAGE

async def broadcast_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle the message to broadcast"""
    message_text = update.message.text
    
    if not message_text:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.")
        return BROADCAST_MESSAGE
    
    users = db.get_all_users()
    
    if not users:
        await update.message.reply_text("–í –±–∞–∑–µ –Ω–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏.")
        return ConversationHandler.END
    
    # Log broadcast event
    db.log_event("broadcast", update.effective_user.id, {"message_length": len(message_text)})
    
    progress_message = await update.message.reply_text(f"–ù–∞—á–∏–Ω–∞—é —Ä–∞—Å—Å—ã–ª–∫—É –¥–ª—è {len(users)} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π...")
    
    success_count = 0
    fail_count = 0
    
    # Show progress updates periodically
    progress_interval = max(1, len(users) // 10)
    last_progress_update = time.time()
    
    for i, (user_id, chat_id) in enumerate(users):
        try:
            await context.bot.send_message(chat_id=chat_id, text=message_text)
            success_count += 1
            
            # Update progress message periodically
            if (i % progress_interval == 0 or i == len(users) - 1) and time.time() - last_progress_update > 2:
                progress_percent = int((i + 1) / len(users) * 100)
                await progress_message.edit_text(
                    f"–†–∞—Å—Å—ã–ª–∫–∞: {progress_percent}% ({i+1}/{len(users)})\n"
                    f"‚úÖ –£—Å–ø–µ—à–Ω–æ: {success_count}\n"
                    f"‚ùå –û—à–∏–±–æ–∫: {fail_count}"
                )
                last_progress_update = time.time()
            
            # Add a small delay to avoid hitting rate limits
            await asyncio.sleep(0.05)
        except Exception as e:
            logger.error(f"Failed to send message to user {user_id}: {e}")
            fail_count += 1
    
    # Final results with buttons
    keyboard = [
        [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏", callback_data="menu_admin")],
        [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="back_to_main")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await progress_message.edit_text(
        f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞\n\n"
        f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
        f"‚Ä¢ –í—Å–µ–≥–æ –ø–æ–ª—É—á–∞—Ç–µ–ª–µ–π: {len(users)}\n"
        f"‚Ä¢ –£—Å–ø–µ—à–Ω–æ –¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: {success_count}\n"
        f"‚Ä¢ –û—à–∏–±–æ–∫ –¥–æ—Å—Ç–∞–≤–∫–∏: {fail_count}",
        reply_markup=reply_markup
    )
    
    return ConversationHandler.END

async def cancel_broadcast(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Cancel the broadcast conversation"""
    query = update.callback_query
    await query.answer()
    
    await query.edit_message_text(
        "‚ùå –†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.",
        reply_markup=InlineKeyboardMarkup([[
            InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏", callback_data="menu_admin")
        ]])
    )
    
    return ConversationHandler.END

async def clean_previous_menus(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Delete previous menu messages to keep the chat clean"""
    if context.user_data.get('menu_messages'):
        for chat_id, message_id in context.user_data['menu_messages'][-3:]:  # Keep only last 3 to avoid too many deletions
            try:
                await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
            except Exception as e:
                logger.debug(f"Could not delete message {message_id}: {e}")
        
        # Clear the list after deletion attempts
        context.user_data['menu_messages'] = []

def chat_id_from_update(update: Update) -> int:
    """Extract chat ID from an update object"""
    if update.effective_chat:
        return update.effective_chat.id
    elif update.callback_query and update.callback_query.message:
        return update.callback_query.message.chat_id
    elif update.message:
        return update.message.chat_id
    else:
        # Fallback - should not happen in normal operation
        return 0

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle all button callbacks"""
    query = update.callback_query
    await query.answer()
    
    # Update user activity
    db.update_user_activity(query.from_user.id)
    
    # Log button event
    db.log_event("button_click", query.from_user.id, {"button": query.data})
    
    # Main menu options
    if query.data == "back_to_main" or query.data == "menu_main":
        await show_main_menu(update, context)
    elif query.data == "menu_check":
        result = await show_check_menu(update, context)
        context.user_data['expecting_check'] = True
    elif query.data == "menu_help":
        await show_help_menu(update, context)
    elif query.data == "menu_admin":
        await show_admin_menu(update, context)
    
    # Admin panel options
    elif query.data == "admin_add":
        result = await show_add_menu(update, context)
        context.user_data['expecting_add'] = True
    elif query.data == "admin_remove":
        result = await show_remove_menu(update, context)
        context.user_data['expecting_remove'] = True
    elif query.data == "admin_list":
        await show_list_menu(update, context)
    elif query.data == "admin_stats":
        await show_stats_menu(update, context)
    elif query.data == "admin_broadcast":
        await query.edit_message_text(
            "–î–ª—è –Ω–∞—á–∞–ª–∞ —Ä–∞—Å—Å—ã–ª–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /broadcast",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥", callback_data="menu_admin")
            ]])
        )
    
    # Whitelist pagination
    elif query.data in ["whitelist_next", "whitelist_prev"]:
        await handle_whitelist_pagination(update, context)
    elif query.data == "whitelist_info":
        # Just acknowledge the button press without doing anything
        pass
    
    # Broadcast cancel
    elif query.data == "broadcast_cancel":
        await cancel_broadcast(update, context)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handler for processing all non-command messages"""
    if not update.message or not update.message.text:
        return
    
    # Update user activity
    db.update_user_activity(update.effective_user.id)
    
    text = update.message.text.strip()
    
    # Handle different conversation states
    if context.user_data.get('expecting_check'):
        context.user_data['expecting_check'] = False
        await handle_check_value(update, context)
    elif context.user_data.get('expecting_add'):
        context.user_data['expecting_add'] = False
        await handle_add_value(update, context)
    elif context.user_data.get('expecting_remove'):
        context.user_data['expecting_remove'] = False
        await handle_remove_value(update, context)
    else:
        # Normal message handling - check whitelist
        if db.check_whitelist(text):
            keyboard = [[InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_main")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                f"‚úÖ –ó–Ω–∞—á–µ–Ω–∏–µ \"{text}\" *–Ω–∞–π–¥–µ–Ω–æ* –≤ –≤–∞–π—Ç–ª–∏—Å—Ç–µ!",
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        else:
            keyboard = [
                [InlineKeyboardButton("üîç –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –¥—Ä—É–≥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ", callback_data="menu_check")],
                [InlineKeyboardButton("‚óÄÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_main")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await update.message.reply_text(
                f"‚ùå –ó–Ω–∞—á–µ–Ω–∏–µ \"{text}\" *–Ω–µ –Ω–∞–π–¥–µ–Ω–æ* –≤ –≤–∞–π—Ç–ª–∏—Å—Ç–µ.",
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )

def main() -> None:
    """Start the bot"""
    # Get the bot token from environment variables
    token = os.getenv("BOT_TOKEN")
    if not token:
        logger.error("No BOT_TOKEN found in environment variables!")
        return
    
    # Initialize database
    try:
        logger.info("Initializing database...")
        global db
        db = Database()
        logger.info("Database initialized successfully")
    except Exception as e:
        logger.error(f"Error initializing database: {e}")
        return
    
    # Create the Application
    application = Application.builder().token(token).build()
    
    # Add command handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("admin", show_admin_menu))
    application.add_handler(CommandHandler("stats", stats_command))
    application.add_handler(CommandHandler("list", show_list_menu))
    
    # Add conversation handler for check
    check_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("check", show_check_menu)],
        states={
            AWAITING_CHECK_VALUE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_check_value)]
        },
        fallbacks=[CallbackQueryHandler(button_callback)],
        name="check_conversation",
        persistent=False
    )
    application.add_handler(check_conv_handler)
    
    # Add conversation handler for add
    add_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("add", show_add_menu)],
        states={
            AWAITING_ADD_VALUE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_add_value)]
        },
        fallbacks=[CallbackQueryHandler(button_callback)],
        name="add_conversation",
        persistent=False
    )
    application.add_handler(add_conv_handler)
    
    # Add conversation handler for remove
    remove_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("remove", show_remove_menu)],
        states={
            AWAITING_REMOVE_VALUE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_remove_value)]
        },
        fallbacks=[CallbackQueryHandler(button_callback)],
        name="remove_conversation",
        persistent=False
    )
    application.add_handler(remove_conv_handler)
    
    # Add conversation handler for broadcast
    broadcast_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("broadcast", broadcast_command)],
        states={
            BROADCAST_MESSAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, broadcast_message)]
        },
        fallbacks=[CallbackQueryHandler(cancel_broadcast, pattern="^broadcast_cancel$")],
        name="broadcast_conversation",
        persistent=False
    )
    application.add_handler(broadcast_conv_handler)
    
    # Add callback query handler
    application.add_handler(CallbackQueryHandler(button_callback))
    
    # Add message handler
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    # Start the Bot
    logger.info("Starting bot...")
    application.run_polling()
    
    logger.info("Bot stopped")

if __name__ == "__main__":
    main() 
